@using ChartJs.Blazor.PieChart

<Chart Config="pieConfig"></Chart>

@code {
    private PieConfig pieConfig = new PieConfig();
    [Parameter]
    public float hours { get; set; } = 10;
    [Parameter]
    public float daylightHours { get; set; } = 12;
    [Parameter]
    public float? concurrent { get; set; }
    [Parameter]
    public bool showLegend { get; set; } = true;
    protected override void OnParametersSet()
    {
        UpdateDataset();
    }

    protected override void OnInitialized()
    {
        pieConfig = new PieConfig(true)
        {
            Options = new PieOptions
            {
                Responsive = true,
                AspectRatio = 3,
                Legend = new Legend
                {
                    Display = showLegend,
                },
                Title = new OptionsTitle
                {
                    Display = false,
                    Text = "Running Hours",
                    FontSize = 20,
                    Position = Position.Bottom,
                    LineHeight = 4,
                },
                Circumference = 3,
                Rotation = -9.341,
                Animation = new ArcAnimation
                {
                    AnimateRotate = true,
                    Duration = 5,

                },
                Tooltips = new Tooltips
                {
                    Enabled = true,
                    Mode = InteractionMode.Index,
                    Intersect = false,
                },
                Hover = new Hover
                {
                    Mode = InteractionMode.Index,
                    Intersect = false
                },
                CutoutPercentage = 70
            }
        };
    }
    public void UpdateDataset()
    {
        if(float.IsInfinity(hours))
        {
            hours = 12;
        }

        pieConfig.Data.Datasets.Clear();
        pieConfig.Data.Labels.Clear();

        foreach (string label in new[] { "Runnable Hours", "Concurrent Hours", "Remaining"})
        {
            pieConfig.Data.Labels.Add(label);
        }
        float remaining = (24 - daylightHours) - hours;
        if(remaining < 0)
        {
            remaining = 0;
        }

        if (concurrent != null) {
            float concurrentRemaining = 4 - (float) concurrent;
            if(concurrentRemaining < 0)
            {
                concurrentRemaining = 0;
            }

            string[] colors = new[] {
                GetColorGradient(hours),
                GetColorGradient((float)concurrent, 4),
                ColorUtil.ColorHexString(156, 163, 175)
            };

            PieDataset<float?> pieDataset = new PieDataset<float?>(new float?[] {hours, null, remaining })
            {
                BackgroundColor = colors,
            };
            PieDataset<float?> pieDataset2 = new PieDataset<float?> (new float?[] { null, (float) concurrent, concurrentRemaining })
            {
                BackgroundColor = colors,
            };

            if (pieConfig != null)
            {
                pieConfig.Data.Datasets.Add(pieDataset);
                pieConfig.Data.Datasets.Add(pieDataset2);
                StateHasChanged();
            }
        } else {
            string[] colors = {
                GetColorGradient(hours),
                ColorUtil.ColorHexString(156, 163, 175)
            };

            PieDataset<float?> pieDataset = new PieDataset<float?>(new float?[] {hours, null, remaining })
            {
                BackgroundColor = GetColorGradient(hours),
            };


            if (pieConfig != null)
            {
                pieConfig.Data.Datasets.Add(pieDataset);
                StateHasChanged();
            }
        }
    }

    private string GetColorGradient(float hours, float range = 12)
    { 
        @* middle top : 46,90,155 
        middle bottom: 255,193,8 
        top 31, 56, 100 
        bottom 241,70,36)*@ 

        byte topR = 31, topG = 56, topB = 100; //Top
        byte middleTopR = 46, middleTopG = 90, middleTopB = 155; //Top middle
        byte middleBottomR = 255, middleBottomG = 193, middleBottomB = 8; // Bottom middle
        byte bottomR = 241, bottomG = 70, bottomB = 0; // Bottom
        
        byte redValue, greenValue, blueValue = 0;

        if (hours <= range / 4)
        {
            redValue = bottomR;
            greenValue = bottomG;
            blueValue = bottomB;
        }
        else if (hours >= range)
        {
            redValue = topR;
            greenValue = topG;
            blueValue = topB;
        } 
        else if(hours < (range * 2 / 3) && hours >= (range / 2)) {
            @* float t = (hours - (range / 2)) / ((range * 2 / 3 - (range / 2)));
            redValue = (byte)(t * middleTopR + (1 - t) * middleBottomR); // Decreasing red component
            greenValue = (byte)(t * middleTopG + (1 - t) * middleBottomG); // Increasing green component
            blueValue = (byte)(t * middleTopB + (1 - t) * middleBottomB); // Increasing blue component *@
            redValue = middleBottomR;
            greenValue = middleBottomG;
            blueValue = middleBottomB;
        } 
        else if (hours < (range / 2))
        {
            Console.WriteLine("Here 1");
            float t = (hours - (range / 4)) / ((range / 2) - (range / 4)); 
            redValue = (byte)((t * middleBottomR) + (1 - t) * bottomR); // Decreasing red component
            greenValue = (byte)(t * middleBottomG + (1 - t) * bottomG); // Increasing green component
            blueValue = (byte)(t * middleBottomB + (1 - t) * bottomB); // Increasing blue component
        }
        else
        {
            Console.WriteLine("Here 2");
            float t = (hours - (range * 2 / 3)) / (range - (range * 2 / 3));
            redValue = (byte)(t * topR + (1 - t) * middleTopR); // Decreasing red component
            greenValue = (byte)(t * topG + (1 - t) * middleTopG); // Increasing green component
            blueValue = (byte)(t * topB + (1 - t) * middleTopB); // Increasing blue component
        }

        return ColorUtil.ColorHexString(redValue, greenValue, blueValue);
    }



}