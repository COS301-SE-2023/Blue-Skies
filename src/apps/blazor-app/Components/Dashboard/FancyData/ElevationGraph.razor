@using ChartJs.Blazor.LineChart

@namespace BlazorApp.FancyData

<div>
    <Chart Config="lineConfig" />
</div>

@code {

    [Parameter] public string? elevationValues { get; set; }
    private LineConfig? lineConfig;

    [Parameter]
    public bool animated { get; set; } = true;

    @* OnParametersSet *@
    protected override void OnParametersSet()
    {
        if (elevationValues != null)
        {
            CalculateData();
        }
    }
    protected override void OnInitialized()
    {

        lineConfig = new LineConfig
        {
            Options = new LineOptions
            {
                Responsive = true,
                Title = new OptionsTitle
                {
                    Display = true,
                    Text = "Elevation Data"
                },
                Scales = new Scales
                {
                    YAxes = new List<CartesianAxis>
                    {
                        new LinearCartesianAxis
                        {
                            ScaleLabel = new ScaleLabel
                            {
                                LabelString = "Height",
                                Display = true,
                            },
                            Ticks = new LinearCartesianTicks
                            {
                                BeginAtZero = true, // This ensures the y-axis starts at zero
                            }
                        }
                    }
                }
            }
        };

        if (!animated)
        {
            lineConfig.Options.Animation = new Animation
            {
                Duration = 0
            };
        }

    }

    @* Calculate Data *@
    private void CalculateData()
    {
        lineConfig!.Data.Labels.Clear();
        lineConfig.Data.Datasets.Clear();
        if (elevationValues == null)
        {
            Console.WriteLine("No elevation data");
            return;
        }
        elevationValues = elevationValues.Replace("[", "");
        elevationValues = elevationValues.Replace("]", "");
        double[] dataArr = new double[0];
        try
        {
            dataArr = elevationValues.Split(',').Select(double.Parse).ToArray();
        }
        catch
        {
            string[] arr = elevationValues.Split(',').ToArray();
            string[] newArr = new string[arr.Length];
            for (int i = 0; i < arr.Length; i++)
            {
                newArr[i] = arr[i].Replace(".", ",");
            }
            dataArr = newArr.Select(double.Parse).ToArray();
        }
        double[] xValues = new double[dataArr.Length / 2 + 1];
        double[] yValues = new double[dataArr.Length / 2 + 1];
        for (int i = 0; i < dataArr.Length; i++)
        {
            if(i % 2 == 0)
            {
                xValues[i / 2] = dataArr[i];
                if(dataArr[i] >= 180) {
                    xValues[i / 2] = dataArr[i] - 360;
                }
            }
            else
            {
                yValues[i / 2] = Math.Round(dataArr[i], 2);   

            }
        }
        xValues[xValues.Length - 1] = xValues[0];
        yValues[yValues.Length - 1] = yValues[0];

        @* Put the first half of the array to the back of the array *@
        double[] tempX = new double[xValues.Length];
        double[] tempY= new double[yValues.Length];
        for (int i = 0; i < xValues.Length; i++)
        {
            tempX[i] = xValues[i];
            tempY[i] = yValues[i];
        }
        for (int i = 0; i < xValues.Length; i++)
        {
            if (i < xValues.Length / 2)
            {
                xValues[i] = tempX[i + xValues.Length / 2];
                yValues[i] = tempY[i + xValues.Length / 2];
            }
            else
            {
                xValues[i] = tempX[i - xValues.Length / 2];
                yValues[i] = tempY[i - xValues.Length / 2];
            }
        }
        xValues[xValues.Length - 1] = 180;

        for (int i = 0; i < xValues.Length; i++)
        {
            string label = xValues[i].ToString();
            if(xValues[i] == 0) {
                label = "N : " + label;
            } else if (xValues[i] == 90) {
                label = "E : " + label;
            } else if (xValues[i] == 180 || xValues[i] == -180) {
                label = "S : " + label;
            } else if (xValues[i] == -90) {
                label = "W : " + label;
            }
            lineConfig.Data.Labels.Add(label);
        }

        IDataset<double> elevationDataset = new LineDataset<double>(yValues)
        {
            Label = "Elevation",
            BackgroundColor = "rgba(0,15,82, 1)",
            BorderColor = "rgba(0,15,82, 1)",
            BorderWidth = 1,
            Fill = FillingMode.Disabled
        };
        lineConfig.Data.Datasets.Add(elevationDataset);

        addSunDataSet(35, 60, "June solstice", xValues, yValues, "rgba(246,135,18, 1)");
        addSunDataSet(55, 90, "Equinox", xValues, yValues, "rgba(255,193,8, 1)");
        addSunDataSet(80, 120, "December solstice", xValues, yValues, "rgba(0,15,82, 1)");

        @* Set the max YAxes to 1.25 the max value of the highest elevation point *@
        double maxY = Math.Max(yValues.Max(), 80) * 1.25;

        lineConfig.Options.Scales = new Scales
        {
            YAxes = new List<CartesianAxis>
            {
                new LinearCartesianAxis
                {
                    Ticks = new LinearCartesianTicks
                    {
                        Max = maxY 
                    }
                }
            }
        };
    }

    private void addSunDataSet(int MaxHeight, int maxLength, string labelName, double[] xValues, double[] yValues, string color = "rgba(255, 255, 0, 1)") {
        double[] xSunValues = new double[xValues.Length];
        double[] ySunValues = new double[yValues.Length];

        for(int i = 0; i < xValues.Length; i++)
        {
            xSunValues[i] = xValues[i];
            ySunValues[i] = double.NaN;

            if(xSunValues[i] >= -maxLength && xSunValues[i] <= maxLength) {
                ySunValues[i] = Math.Pow((xSunValues[i] / maxLength), 2) * -MaxHeight + MaxHeight;
            }
        }

        IDataset<double> sunDataset = new LineDataset<double>(ySunValues)
        {
            Label = labelName,
            BackgroundColor = color,
            BorderColor = color,
            BorderWidth = 1,
            Fill = FillingMode.Disabled
        };

        lineConfig!.Data.Datasets.Add(sunDataset);
    }
}
