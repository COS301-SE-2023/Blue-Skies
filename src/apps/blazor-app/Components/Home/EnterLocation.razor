@using BlazorApp.Components.Base
@using BlazorApp.Components.Home
@using BlazorApp.Models
@using System.Text.Json;
@using System.Net;
@using System.Collections.Generic;
@using System.Net.Http;
@using System.Threading.Tasks;
@using System.Threading.Tasks.Dataflow;
@using System.Collections.Concurrent;
@inject ProtectedSessionStorage ProtectedSessionStore
@inject NavigationManager NavigationManager
@inject BlazorApp.Data.LoadingService loadingService

<div class="mx-auto max-w-2xl px-10  py-32 sm:py-20 lg:py-28">
    <div class="text-center">
        <Heading>
            <Header>
                <h1 class="text-4xl font-bold tracking-tight text-primary-950 sm:text-6xl">Discover Your Solar Score
                </h1>
            </Header>
            <Subscript>
                <p class="mt-6 text-lg leading-8 text-gray-600 mb-5">Uncover Your Solar Potential. Calculate Your Solar
                    Score Today.</p>
            </Subscript>
        </Heading>
        <div>
            <AutoComplete />
        </div>
        <div class="mt-10 flex flex-col sm:flex-row items-center justify-center gap-6">
            <div @onclick="generateLocationData">
                <Button style="pill" css="h-14">
                    <content>
                        <p class="text-sm font-semibold hover:text-white">Get Solar Score</p>
                    </content>
                </Button>
            </div>
            <a href="/dashboard" @onclick="() => loadingService.ShowLoadingScreen()" class="text-sm font-normal leading-6 text-orange-accent-500">Dashboard<span
                    aria-hidden="true"></span></a>
        </div>
    </div>
</div>


@code {
    private LocationDataModel? currentLocationData = new LocationDataModel();
    public string parent = "index";
    private string? API_PORT = Environment.GetEnvironmentVariable("API_PORT");
    private double latitude = 0;
    private double longitude = 0;
    private readonly int zoom = 19;
    private readonly int width = 600;
    private readonly int height = 500;

    /// <summary>
    /// Gets the parent page from the session storage.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        var par = await ProtectedSessionStore.GetAsync<string>("parent");
        parent = par.Value!;
    }

    /// <summary>
    /// A class to store the elevation data for each location.
    /// </summary>
    class Elevations
    {
        private readonly ConcurrentDictionary<int, double> data = new ConcurrentDictionary<int, double>();

        public void Set(int id, double elevation)
        {
            data[id] = elevation;
        }

        public double Get(int id)
        {
            if (data.TryGetValue(id, out double elevation))
            {
                return elevation;
            }
            return 0.0; // You may want to handle this case differently
        }
    }

    /// <summary>
    /// <list type="number">
    ///     <item>Gets the longitude and latitude from the location suggestion.</item>
    ///     <item>Gets the location name from the location suggestion.</item>
    ///     <item>Checks if the location data exists in the database.</item>
    ///     <item>If the location data does not exist:</item>
    ///     <list type="bullet">
    ///         <item>Gets the daylight hours for the location.</item>
    ///         <item>Downloads the image from the Google Maps Static API.</item>
    ///         <item>Saves the image to the local storage.</item>
    ///         <item>Creates a new row in the database for the location data.</item>
    ///     </list>
    ///     <item>Saves the location data to the currentLocationData variable.</item>
    ///     <item>Saves the currentLocationData variable to the session storage.</item>
    ///     <item>Navigates to the solarScore page.</item>
    /// </list>
    /// </summary>

    public async void generateLocationData()
    {
        ShowLoadingScreen();
        System.Globalization.CultureInfo customCulture = (System.Globalization.CultureInfo)System.Threading.Thread.CurrentThread.CurrentCulture.Clone();
        customCulture.NumberFormat.NumberDecimalSeparator = ".";
        System.Threading.Thread.CurrentThread.CurrentCulture = customCulture;
        var locationTemp = await ProtectedSessionStore.GetAsync<LocationSuggestion>("location");
        LocationSuggestion locationSuggestion = locationTemp.Value!;

        List<double> cord = new List<double>();
        if (locationSuggestion.Geometry != null)
        {
            cord = locationSuggestion.Geometry.Coordinates!;
        }
        longitude = cord[0];
        latitude = cord[1];
        var location = "";
        if (locationSuggestion != null)
        {
            location = locationSuggestion.Place_Name;
        }

        currentLocationData!.location = location;
        currentLocationData.latitude = latitude;
        currentLocationData.longitude = longitude;

        await ProtectedSessionStore.SetAsync("latitude", latitude);
        await ProtectedSessionStore.SetAsync("longitude", longitude);


        byte[] imageBytes = new byte[0];
        bool exists = await GetLocationData(latitude, longitude);
        if (!exists)
        {
            await getInitialData(latitude, longitude);
            imageBytes = await DownloadImageFromGoogleMapsService();
            await CreateLocationData(latitude, longitude, (float)currentLocationData.daylightHours, Convert.ToBase64String(imageBytes), location);
        }

        await ProtectedSessionStore.SetAsync("parent", "");
        parent = "";
        await ProtectedSessionStore.SetAsync("edit", false);

        if (parent.Equals("index"))
        {
            loadingService.ShowLoadingScreen();
            NavigationManager.NavigateTo("/solarScore");
        }
        else
        {
            NavigationManager.NavigateTo("/solarScore", true);
            ShowLoadingScreen();
        }
    }
    
    /// <summary>
    /// <para>Gets the elevation data for the given location.</para>
    /// <paramref name="latitude"/> The latitude of the location.
    /// <paramref name="longitude"/> The longitude of the location.
    /// </summary>
    private async Task<string> getElevationData(double latitude, double longitude) {
        string url = $"https://api.globalsolaratlas.info/data/horizon?loc={latitude},{longitude}";
        Console.WriteLine("URL: " + url);
        var client = new HttpClient();
        var response = await client.GetAsync(url);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadAsStringAsync();
    }

    /// <summary>
    /// <para>Fetches the weather data from the visualcrossing api.</para>
    /// <paramref name="client"/> The http client.
    /// <paramref name="apiUrl"/> The url to the api.
    /// </summary>
    #pragma warning disable CS8603
    private async Task<WeatherData> FetchWeatherDataAsync(HttpClient client, string apiUrl)
    {
        try
        {
            var response = await client.GetAsync(apiUrl);
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadAsStringAsync();
                if (result != null && result.Length > 0 && result[0] == '{')
                {
                    return JsonSerializer.Deserialize<WeatherData>(result);
                }
            }
            else
            {
                Console.WriteLine($"Failed to call the API. Status code: {response.StatusCode}");
            }
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"HTTP Request Error: {ex.Message}");
        }

        // If any error occurred, return null or an appropriate default value
        return null;
    }

    /// <summary>
    /// <para>Calls the weather visualcrossing api to get quick initial data.</para>
    /// <paramref name="latitude"/> The latitude of the current location.
    /// <paramref name="longitude"/> The longitude of the current location.
    /// </summary>
    public async Task getInitialData(double latitude, double longitude)
    {
        var data = new List<WeatherData>();
        @* Initial api key to get the last 15 day's of information: *@
        var client = new HttpClient();
        var apiKey = Environment.GetEnvironmentVariable("VISUAL_CROSSING_WEATHER_API_KEY");
        var apiUrl = $"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{latitude},{longitude}?unitGroup=metric&include=days&key={apiKey}&elements=sunrise,sunset,temp,solarenergy,solarradiation,datetime";
        data.Add(await FetchWeatherDataAsync(client, apiUrl));
        
        @* 11 other calls to get the last 10 month's data *@
        var currentMonth = DateTime.Now.Month;
        var tasks = new List<Task<WeatherData>>();

        for (var i = 1; i < 12; i++)
        {
            var month = currentMonth - i;
            if (month < 1)
            {
                month = 12 + month;
            }
            var year = DateTime.Now.Year;
            if (month > currentMonth)
            {
                year = year - 1;
            }
            var monthString = month.ToString();
            if (month < 10)
            {
                monthString = "0" + monthString;
            }
            client = new HttpClient();
            apiUrl = $"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{latitude},{longitude}/{year}-{monthString}-15/{year}-{monthString}-15?unitGroup=metric&include=days&key={apiKey}&elements=sunrise,sunset,temp,solarenergy,solarradiation,datetime";

            // Asynchronously fetch the data and add the task to the list
            tasks.Add(FetchWeatherDataAsync(client, apiUrl));
        }

        // Wait for all tasks to complete
        await Task.WhenAll(tasks);

        // Extract the results from completed tasks
        var completedResults = tasks
            .Where(task => task.Status == TaskStatus.RanToCompletion)
            .Select(task => task.Result)
            .ToList();

        // Now, completedResults contains the fetched data for all 10 months
        foreach (var result in completedResults)
        {
            if (result != null)
            {
                data.Add(result);
            }
        }

        @* Get averageSolarIrradiation and daylightHours from the data *@
        var averageSunlightHours = 0f;
        var averageSolarIrradiation = 0.0;
        for(var i = 0; i < data.Count; i++) {
            if(data[i] == null || data[i].days == null) {
                Console.WriteLine("Data is null");
                continue;
            }

            var averageSolarIrradiationMonth = 0.0;
            var monthSunlightHours = 0f;

            #pragma warning disable CS8602
            for(var j = 0; j < data[i].days.Count; j++) {
                var sunrise = data[i].days[j].sunrise;
                var sunset = data[i].days[j].sunset;
                var sunriseSplit = sunrise.Split(":");
                var sunsetSplit = sunset.Split(":");
                var sunriseTotalHours =  float.Parse(sunriseSplit[0]) + (float.Parse(sunriseSplit[1]) / 60);
                var sunsetTotalHours = float.Parse(sunsetSplit[0]) + (float.Parse(sunsetSplit[1]) / 60);
                var daylightHours = sunsetTotalHours - sunriseTotalHours;
                monthSunlightHours += daylightHours;

                averageSolarIrradiationMonth += data[i].days[j].solarradiation;
            }
            monthSunlightHours = monthSunlightHours / data[i].days.Count;
            averageSunlightHours += monthSunlightHours;

            averageSolarIrradiationMonth = averageSolarIrradiationMonth / data[i].days.Count;
            averageSolarIrradiation += averageSolarIrradiationMonth;
        }
        averageSunlightHours = averageSunlightHours / data.Count;
        averageSunlightHours = (float)Math.Round(averageSunlightHours, 2);
        averageSolarIrradiation = averageSolarIrradiation / data.Count;

        currentLocationData.daylightHours = averageSunlightHours;
        await ProtectedSessionStore.SetAsync("tempSolarIrradiation", averageSolarIrradiation);
    }

    /// <summary>
    /// <list type="bulltet">
    ///     <item>Tries to get the location data from the database.</item>
    ///     <item>If the data exists: save it's data to the currentLocationData variable and return true.</item>
    ///     <item>If the data does not exist: return false.</item>
    /// </list>
    /// <paramref name="latitude"/> The latitude of the current location.
    /// <paramref name="longitude"/> The longitude of the current location.
    /// </summary>
    public async Task<bool> GetLocationData(double latitude, double longitude){
        var client = new HttpClient();
        var request = new HttpRequestMessage(HttpMethod.Get, API_PORT + "/locationData/GetLocationData/" + latitude + "/" + longitude);
        var response = await client.SendAsync(request);
        if (response.IsSuccessStatusCode)
        {
            Console.WriteLine("Location data found");
            string data = response.Content.ReadAsStringAsync().Result;
            currentLocationData = JsonSerializer.Deserialize<LocationDataModel>(data);
            return true;
        } else {
            Console.WriteLine("Location data not found - fetching data instead");
            return false;
        }
    }
    
    /// <summary>
    /// <list type="number">
    ///     <item>Creates a new row in the database for the location data. </item>
    ///     <item>Calls the python API to get the solar irradiation data for that location.</item>
    /// </list>
    /// <paramref name="latitude"/> The latitude of the current location.
    /// <paramref name="longitude"/> The longitude of the current location.
    /// <paramref name="daylightHours"/> The daylight hours for the current location.
    /// <paramref name="image"/> The image of the current location.
    /// <paramref name="location"/> The name of the current location.
    /// </summary>
    public async Task CreateLocationData(double latitude, double longitude, float daylightHours, string image, string location) 
    {
        string  elevationData = await getElevationData(latitude, longitude);
        Console.WriteLine("Elevation data: " + elevationData);
        var numYears = 3;
        var numDaysPerYear = 48;
        var client = new HttpClient();
        var request = new HttpRequestMessage(HttpMethod.Post, API_PORT + "/locationData/create");
        var content = new StringContent("{\r\n    \"latitude\": \"" 
                                    + latitude 
                                    + "\",\r\n    \"longitude\": \"" 
                                    + longitude 
                                    + "\",\r\n    \"location\": \"" 
                                    + location 
                                    + "\",\r\n    \"daylightHours\" : \"" 
                                    + daylightHours 
                                    + "\",\r\n    \"image\": \"" 
                                    + image 
                                    + "\" ,\r\n    \"elevationData\": \"" 
                                    + elevationData +"\"\r\n}", null, "application/json");
        
        request.Content = content;
        var response = await client.SendAsync(request);
        if (response.IsSuccessStatusCode)
        {
            client = new HttpClient();
            request = new HttpRequestMessage(HttpMethod.Get, API_PORT + "/locationData/getSolarIrradiationData");
            content = new StringContent("{\r\n    \"latitude\": "+ latitude + ",\r\n    \"longitude\": " + longitude + ",\r\n    \"numYears\": "+ numYears + ",\r\n    \"numDaysPerYear\": "+ numDaysPerYear +"\r\n}", null, "application/json");
            request.Content = content;
            response = await client.SendAsync(request);
            if (response.IsSuccessStatusCode)
            {
                Console.WriteLine("Successfully called python file");

            } else {
                Console.WriteLine("Failed to call python file");
            }
        } else {
            Console.WriteLine("Failed to create row table in database for solarIrradiation data");
        }
    } 
    

    /// <summary>
    /// Downloads the image from the Google Maps Static API returns it as a byte array.
    /// </summary>
    private async Task<byte[]> DownloadImageFromGoogleMapsService()
    {
        byte[] imageBytes = new byte[0];
        var googleMapsService = new GoogleMapsService(new HttpClient());
        imageBytes = await googleMapsService.DownloadStaticMapImageAsync(latitude, longitude, zoom, width, height);
        return imageBytes;
    }

    /// <summary>
    /// Saves the image as a bytes array to the local storage.
    /// <paramref name="imageBytes"/> The image as a byte array.
    /// </summary>
    private async Task SaveImageToLocalStorage(byte[] imageBytes)
    {
        if(imageBytes.Length == 0) {
            Console.WriteLine("Image bytes is empty");
            return;
        }
        var imagePath = Path.Combine("wwwroot", "assets", "map_image.png");
        if (File.Exists(imagePath))
        {
            File.Delete(imagePath);
        }
        await File.WriteAllBytesAsync(imagePath, imageBytes);
    }
    
    private void ShowLoadingScreen()
    {
        loadingService.ShowLoadingScreen();
    }

    private void HideLoadingScreen()
    {
        loadingService.HideLoadingScreen();
    }
}